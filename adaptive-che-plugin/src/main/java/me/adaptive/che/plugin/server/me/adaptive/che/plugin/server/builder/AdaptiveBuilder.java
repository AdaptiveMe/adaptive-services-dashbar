/*
 * Copyright 2014-2015. Adaptive.me.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 */

package me.adaptive.che.plugin.server.me.adaptive.che.plugin.server.builder;

import me.adaptive.che.infrastructure.vfs.WorkspaceIdLocalFSMountStrategy;
import me.adaptive.infra.client.ApiClient;
import me.adaptive.infra.client.api.BuildRequestBody;
import org.eclipse.che.api.builder.BuildStatus;
import org.eclipse.che.api.builder.BuilderException;
import org.eclipse.che.api.builder.dto.BaseBuilderRequest;
import org.eclipse.che.api.builder.internal.*;
import org.eclipse.che.api.core.notification.EventService;
import org.eclipse.che.api.core.util.CommandLine;

import javax.inject.Inject;
import javax.inject.Named;
import java.io.File;
import java.util.Arrays;
import java.util.concurrent.Callable;

/**
 * This is the class responsible for invoking the build in one of the adaptive builder servers.
 *
 * @author panthro
 * Created by panthro on 26/06/15.
 *
 */
public class AdaptiveBuilder extends Builder {

    public static final String BUILDER_NAME = "adaptive";
    public static final String PLATFORM_OPTION = "platform";
    public static final BuildStatus[] FINISHED_STATUSES = {BuildStatus.CANCELLED, BuildStatus.SUCCESSFUL, BuildStatus.FAILED};
    public static final Long STATUS_CHECK_INTERVAL = 500L;

    private ApiClient apiClient;
    private File buildsRoot;
    private String buildLogName;
    private WorkspaceIdLocalFSMountStrategy workspaceIdLocalFSMountStrategy;

    /**
     * Default constructor.
     *
     * @param rootDirectory         the directory where we can store data
     * @param numberOfWorkers       the number of workers
     * @param queueSize             the size of the queue
     * @param cleanBuildResultDelay delay
     */
    @Inject
    public AdaptiveBuilder(@Named(Constants.BASE_DIRECTORY) java.io.File rootDirectory,
                           @Named(Constants.NUMBER_OF_WORKERS) int numberOfWorkers,
                           @Named(Constants.QUEUE_SIZE) int queueSize,
                           @Named(Constants.KEEP_RESULT_TIME) int cleanBuildResultDelay,
                           @Named("adaptive.api.client.endpoint") String endpoint,
                           @Named("adaptive.api.client.token") String token,
                           @Named("adaptive.build.result.root") String buildsRoot,
                           @Named("adaptive.build.log.name") String buildLogName,
                           WorkspaceIdLocalFSMountStrategy workspaceIdLocalFSMountStrategy,
                           EventService eventService) {
        super(rootDirectory, numberOfWorkers, queueSize, cleanBuildResultDelay, eventService);
        apiClient = new ApiClient(endpoint, token);
        this.buildsRoot = new File(buildsRoot);
        this.buildLogName = buildLogName;
        this.workspaceIdLocalFSMountStrategy = workspaceIdLocalFSMountStrategy;
    }


    @Override
    public String getName() {
        return BUILDER_NAME;
    }

    @Override
    public String getDescription() {
        return "Adaptive Builder";
    }

    /**
     * Builds the {@code BuildResult} accordingly with the result from the given task
     *
     * @param task       the task to build the result
     * @param successful a boolean if the task was successful
     * @return the {@code BuildResult} representing the result of the build
     * @throws BuilderException
     */
    @Override
    protected BuildResult getTaskResult(FutureBuildTask task, boolean successful) throws BuilderException {
        //TODO analyze how che choose which file to display when building from the cli
        File resultRoot = getBuildResultRoot(task.getConfiguration().getRequest());
        File[] resultFiles = resultRoot.listFiles((dir, name) -> !buildLogName.equals(name));
        return new BuildResult(successful, Arrays.asList(resultFiles), new File(resultRoot, buildLogName));
    }

    /**
     * Get the log file generated by the builder based on the request
     *
     * @param request the request
     * @return the log file
     */
    public File getBuildResultLog(BaseBuilderRequest request) {
        return new File(getBuildResultRoot(request), buildLogName);
    }

    /**
     * The build result
     *
     * @param request the request
     * @return the File pointing to the buildResultRoot
     */
    public File getBuildResultRoot(BaseBuilderRequest request) {
        return new File(buildsRoot, getWorkspaceFolderFromRequest(request)
                + File.separator
                + request.getProject()
                + File.separator
                + request.getId());
    }

    /**
     * We are not using the command line, this is for builds that need a command line.
     *
     * @param config the build config
     * @return should return a command line to prevent NullPointerExceptions but it won't do anything
     * @throws BuilderException
     */
    @Override
    protected CommandLine createCommandLine(BuilderConfiguration config) throws BuilderException {
        return new CommandLine("date"); //adding a date to the logs :P
    }


    /**
     * Utility method to get the workspace folder name
     *
     * @param request the request
     * @return the folder name
     */
    private String getWorkspaceFolderFromRequest(BaseBuilderRequest request) {
        return workspaceIdLocalFSMountStrategy.getWorkspaceFolderName(request.getWorkspace());
    }


    @Override
    protected BuildLogger createBuildLogger(BuilderConfiguration buildConfiguration, File logFile) throws BuilderException {
        return new AdaptiveBuilderLogger(buildConfiguration, this, apiClient);
    }

    @Override
    public BuilderConfigurationFactory getBuilderConfigurationFactory() {
        return new AdaptiveBuilderConfigurationFactory(this);
    }

    @Override
    protected Callable<Boolean> createTaskFor(CommandLine commandLine, BuildLogger logger, long timeout, final BuilderConfiguration configuration) {
        return new AdaptiveBuilderTask(configuration);
    }

    public class AdaptiveBuilderTask implements Callable<Boolean> {

        private BuilderConfiguration configuration;
        private BuildStatus status;

        public AdaptiveBuilderTask(BuilderConfiguration configuration) {
            this.configuration = configuration;
        }

        @Override
        public Boolean call() throws Exception {
            status = BuildStatus.IN_QUEUE;
            try {
                apiClient.getBuilderApi().build(
                        configuration.getRequest().getId(),
                        getWorkspaceFolderFromRequest(configuration.getRequest()),
                        configuration.getRequest().getProject()
                        , configuration.getRequest().getOptions().getOrDefault(PLATFORM_OPTION, "android"),
                        new BuildRequestBody()); //TODO build the correct body based on the configuration & request
                status = BuildStatus.IN_PROGRESS;
            } catch (Exception e) {
                status = BuildStatus.FAILED;
                return false;
            }
            while (!Arrays.asList(FINISHED_STATUSES).contains(status)) {
                updateStatusFromRemote();
                Thread.sleep(STATUS_CHECK_INTERVAL);
            }

            return BuildStatus.SUCCESSFUL.equals(status);
        }

        private void updateStatusFromRemote() {
            try {
                String remoteStatus = apiClient.getBuilderApi().status(configuration.getRequest().getId());
                status = BuildStatus.valueOf(remoteStatus.toUpperCase());
            } catch (Exception e) {
                status = BuildStatus.FAILED;
            }
        }

    }
}
